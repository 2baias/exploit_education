#include<err.h>
#include<stdio.h>
#include<stdlib.h>
#include<string.h>
#include<unistd.h>

#define BANNER \
  "Welcome to /phoenix/amd64/stack-six, brought to you by https://exploit.education"

char * what = "Welcome, I am pleased to meet you ";

char *greet(char *who) {
  char buffer[128];
  int maxSize;
  //guessing the stack looks like
  //buffer  | e5c0
  //shit (12 bytes)
  //maxSize | e64c
  //shit (20 bytes)
  //old rbp  | e660
  //ret addr | e668

  maxSize = strlen(who);
  if (maxSize > (sizeof(buffer) - /* ensure null termination */ 1)) {
    maxSize = sizeof(buffer) - 1;
  }

  strcpy(buffer, what);
  //maxsize can be up to 127
  //but this causes an overflow, since buffer already contains the `what` string
  //which is 34 bytes
  //i. e. we can overflow with 34 bytes
  //this seems to invite a `jump back on the stack` kind of attack
  //1. make sure we can jump back into the stack (use 0xcc to check that it works
  //in a non-debug environ.
  //2. write shell-code
  printf("%d\n", strlen(buffer));
  strncpy(buffer + strlen(buffer), who, maxSize);
  printf("%d\n",maxSize);
  return strdup(buffer);
}

int main(int argc, char **argv) {
  char *ptr;
  printf("%s\n", BANNER);

  ptr = getenv("ExploitEducation");
  if (NULL == ptr) {
    // This style of comparison prevents issues where you may accidentally
    // type if(ptr = NULL) {}..

    errx(1, "Please specify an environment variable called ExploitEducation");
  }
  char * greetstr = greet(ptr);
  //printf("farts!\n");
  //printf("more farts!\n");
  //printf("even more farts!\n");
  //the printf below is not needed for a segfault -- this can probably be used
  //printf("%s\n", greetstr);
  return 0;
}
